// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	dto "macaiki/internal/thread/dto"

	mock "github.com/stretchr/testify/mock"

	multipart "mime/multipart"
)

// ThreadUseCase is an autogenerated mock type for the ThreadUseCase type
type ThreadUseCase struct {
	mock.Mock
}

// AddThreadComment provides a mock function with given fields: _a0
func (_m *ThreadUseCase) AddThreadComment(_a0 dto.CommentRequest) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(dto.CommentRequest) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateCommentReport provides a mock function with given fields: commentReport
func (_m *ThreadUseCase) CreateCommentReport(commentReport dto.CommentReportRequest) error {
	ret := _m.Called(commentReport)

	var r0 error
	if rf, ok := ret.Get(0).(func(dto.CommentReportRequest) error); ok {
		r0 = rf(commentReport)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateThread provides a mock function with given fields: _a0, userID
func (_m *ThreadUseCase) CreateThread(_a0 dto.ThreadRequest, userID uint) (dto.ThreadResponse, error) {
	ret := _m.Called(_a0, userID)

	var r0 dto.ThreadResponse
	if rf, ok := ret.Get(0).(func(dto.ThreadRequest, uint) dto.ThreadResponse); ok {
		r0 = rf(_a0, userID)
	} else {
		r0 = ret.Get(0).(dto.ThreadResponse)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(dto.ThreadRequest, uint) error); ok {
		r1 = rf(_a0, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateThreadReport provides a mock function with given fields: threadReport
func (_m *ThreadUseCase) CreateThreadReport(threadReport dto.ThreadReportRequest) error {
	ret := _m.Called(threadReport)

	var r0 error
	if rf, ok := ret.Get(0).(func(dto.ThreadReportRequest) error); ok {
		r0 = rf(threadReport)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteComment provides a mock function with given fields: commentID, threadID, userID, role
func (_m *ThreadUseCase) DeleteComment(commentID uint, threadID uint, userID uint, role string) error {
	ret := _m.Called(commentID, threadID, userID, role)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, uint, uint, string) error); ok {
		r0 = rf(commentID, threadID, userID, role)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteThread provides a mock function with given fields: threadID, userID, role
func (_m *ThreadUseCase) DeleteThread(threadID uint, userID uint, role string) error {
	ret := _m.Called(threadID, userID, role)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, uint, string) error); ok {
		r0 = rf(threadID, userID, role)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DownvoteThread provides a mock function with given fields: threadID, userID
func (_m *ThreadUseCase) DownvoteThread(threadID uint, userID uint) error {
	ret := _m.Called(threadID, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, uint) error); ok {
		r0 = rf(threadID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetCommentsByThreadID provides a mock function with given fields: threadID
func (_m *ThreadUseCase) GetCommentsByThreadID(threadID uint) ([]dto.CommentResponse, error) {
	ret := _m.Called(threadID)

	var r0 []dto.CommentResponse
	if rf, ok := ret.Get(0).(func(uint) []dto.CommentResponse); ok {
		r0 = rf(threadID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]dto.CommentResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint) error); ok {
		r1 = rf(threadID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSavedThread provides a mock function with given fields: userID
func (_m *ThreadUseCase) GetSavedThread(userID uint) ([]dto.DetailedThreadResponse, error) {
	ret := _m.Called(userID)

	var r0 []dto.DetailedThreadResponse
	if rf, ok := ret.Get(0).(func(uint) []dto.DetailedThreadResponse); ok {
		r0 = rf(userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]dto.DetailedThreadResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint) error); ok {
		r1 = rf(userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetThreadByID provides a mock function with given fields: threadID
func (_m *ThreadUseCase) GetThreadByID(threadID uint) (dto.ThreadResponse, error) {
	ret := _m.Called(threadID)

	var r0 dto.ThreadResponse
	if rf, ok := ret.Get(0).(func(uint) dto.ThreadResponse); ok {
		r0 = rf(threadID)
	} else {
		r0 = ret.Get(0).(dto.ThreadResponse)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint) error); ok {
		r1 = rf(threadID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetThreads provides a mock function with given fields: keyword, userID
func (_m *ThreadUseCase) GetThreads(keyword string, userID uint) ([]dto.DetailedThreadResponse, error) {
	ret := _m.Called(keyword, userID)

	var r0 []dto.DetailedThreadResponse
	if rf, ok := ret.Get(0).(func(string, uint) []dto.DetailedThreadResponse); ok {
		r0 = rf(keyword, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]dto.DetailedThreadResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, uint) error); ok {
		r1 = rf(keyword, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetThreadsFromFollowedCommunity provides a mock function with given fields: userID
func (_m *ThreadUseCase) GetThreadsFromFollowedCommunity(userID uint) ([]dto.DetailedThreadResponse, error) {
	ret := _m.Called(userID)

	var r0 []dto.DetailedThreadResponse
	if rf, ok := ret.Get(0).(func(uint) []dto.DetailedThreadResponse); ok {
		r0 = rf(userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]dto.DetailedThreadResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint) error); ok {
		r1 = rf(userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetThreadsFromFollowedUsers provides a mock function with given fields: userID
func (_m *ThreadUseCase) GetThreadsFromFollowedUsers(userID uint) ([]dto.DetailedThreadResponse, error) {
	ret := _m.Called(userID)

	var r0 []dto.DetailedThreadResponse
	if rf, ok := ret.Get(0).(func(uint) []dto.DetailedThreadResponse); ok {
		r0 = rf(userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]dto.DetailedThreadResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint) error); ok {
		r1 = rf(userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTrendingThreads provides a mock function with given fields: userID
func (_m *ThreadUseCase) GetTrendingThreads(userID uint) ([]dto.DetailedThreadResponse, error) {
	ret := _m.Called(userID)

	var r0 []dto.DetailedThreadResponse
	if rf, ok := ret.Get(0).(func(uint) []dto.DetailedThreadResponse); ok {
		r0 = rf(userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]dto.DetailedThreadResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint) error); ok {
		r1 = rf(userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LikeComment provides a mock function with given fields: commentID, userID
func (_m *ThreadUseCase) LikeComment(commentID uint, userID uint) error {
	ret := _m.Called(commentID, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, uint) error); ok {
		r0 = rf(commentID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetThreadImage provides a mock function with given fields: img, threadID, userID
func (_m *ThreadUseCase) SetThreadImage(img *multipart.FileHeader, threadID uint, userID uint) error {
	ret := _m.Called(img, threadID, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(*multipart.FileHeader, uint, uint) error); ok {
		r0 = rf(img, threadID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreSavedThread provides a mock function with given fields: savedThread
func (_m *ThreadUseCase) StoreSavedThread(savedThread dto.SavedThreadRequest) error {
	ret := _m.Called(savedThread)

	var r0 error
	if rf, ok := ret.Get(0).(func(dto.SavedThreadRequest) error); ok {
		r0 = rf(savedThread)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UndoDownvoteThread provides a mock function with given fields: threadID, userID
func (_m *ThreadUseCase) UndoDownvoteThread(threadID uint, userID uint) error {
	ret := _m.Called(threadID, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, uint) error); ok {
		r0 = rf(threadID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UndoUpvoteThread provides a mock function with given fields: threadID, userID
func (_m *ThreadUseCase) UndoUpvoteThread(threadID uint, userID uint) error {
	ret := _m.Called(threadID, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, uint) error); ok {
		r0 = rf(threadID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnlikeComment provides a mock function with given fields: commentID, userID
func (_m *ThreadUseCase) UnlikeComment(commentID uint, userID uint) error {
	ret := _m.Called(commentID, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, uint) error); ok {
		r0 = rf(commentID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateThread provides a mock function with given fields: _a0, threadID, userID
func (_m *ThreadUseCase) UpdateThread(_a0 dto.ThreadRequest, threadID uint, userID uint) (dto.ThreadResponse, error) {
	ret := _m.Called(_a0, threadID, userID)

	var r0 dto.ThreadResponse
	if rf, ok := ret.Get(0).(func(dto.ThreadRequest, uint, uint) dto.ThreadResponse); ok {
		r0 = rf(_a0, threadID, userID)
	} else {
		r0 = ret.Get(0).(dto.ThreadResponse)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(dto.ThreadRequest, uint, uint) error); ok {
		r1 = rf(_a0, threadID, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpvoteThread provides a mock function with given fields: threadID, userID
func (_m *ThreadUseCase) UpvoteThread(threadID uint, userID uint) error {
	ret := _m.Called(threadID, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(uint, uint) error); ok {
		r0 = rf(threadID, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewThreadUseCase interface {
	mock.TestingT
	Cleanup(func())
}

// NewThreadUseCase creates a new instance of ThreadUseCase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewThreadUseCase(t mockConstructorTestingTNewThreadUseCase) *ThreadUseCase {
	mock := &ThreadUseCase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
